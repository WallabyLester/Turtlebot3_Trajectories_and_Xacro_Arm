#!/usr/bin/env python

'''
Publishes a cmd_vel (geometry_msgs/Twist) message at a fixed frequency, causing the turtlebot to follow the desired open-loop trajectory
It is up to you to find an appropriate frequency, but 10 Hz is too slow and 1 kHz is faster than needed.

Broadcasts:
A static transform from world to odom.
The world frame and odom frame are co-located. When the turtlebot is at (0, 0, 0) in the odom frame it is at 0,0,θ0 in the world frame, where θ0 is the initial angle of the robot on its figure-eight trajectory
Thus, when the turtlebot starts, it can initiate its odometry to (0,0,0) but always be facing the correct direction in the odometry frame

Services:
pause (type up to you) Stop the turtle's motion, in a way that the trajectory can be resumed
resume (type up to you) Resume the turtle's motion along the trajectory

Parameters:
width: The width of the figure eight
height: The height of the figure eight
period: The amount of time it takes to complete the figure eight
~pub_freq: The frequency at which to publish the messages. This is a private parameter.
Pick parameters that fit your location and the turtlebot's capabilities.
'''

import rospy
from std_srvs.srv import Empty, EmptyResponse
from geometry_msgs.msg import Twist, Vector3, TransformStamped
import math
from homework2.comp_traj import FigureEight
import tf2_ros
from tf_conversions import transformations
from numpy import sin, pi, cos


class Trajectory:
    """ Calculates based on Figure Eight trajectories and provides coordinates 
    """
    def __init__(self):
        self.__pause = rospy.Service("pause", Empty, self.pause) # temporary service type
        self.__resume = rospy.Service("resume", Empty, self.resume)
        self.pub = rospy.Publisher("turtle1/cmd_vel", Twist, queue_size=10)
        self.stop = rospy.Publisher("turtle1/cmd_vel", Twist, queue_size=10)
        self.__pub_freq = rospy.get_param("~pub_freq")
        self.W = rospy.get_param("parameters/width")
        self.H = rospy.get_param("parameters/height")
        self.T = rospy.get_param("parameters/period")
        self.rate = rospy.Rate(self.__pub_freq)
        self.figure_eight = FigureEight(self.W, self.H, self.T)
        self.flag = False  # use for time
        self.__t = rospy.get_time()
        self.t_paused = rospy.get_time()
        self.t_diff = 0
        self.theta = self.figure_eight.theta0(self.__t)

        self.static_broadcaster = tf2_ros.StaticTransformBroadcaster()

        q1 = transformations.quaternion_from_euler(0, 0 , self.theta)

        static_broadcaster = TransformStamped()
        static_broadcaster.header.stamp = rospy.Time.now()
        static_broadcaster.header.frame_id = "world"
        static_broadcaster.child_frame_id = "odom"

        static_broadcaster.transform.translation.x = 0
        static_broadcaster.transform.translation.y = 0
        static_broadcaster.transform.translation.z = 0

        static_broadcaster.transform.rotation.x = q1[0]
        static_broadcaster.transform.rotation.y = q1[1]
        static_broadcaster.transform.rotation.z = q1[2]
        static_broadcaster.transform.rotation.w = q1[3]
        
        self.static_broadcaster.sendTransform(static_broadcaster)

    def pause(self, event=None):
        self.flag = False
        #self.stop.publish(Twist(Vector3(x=0, y=0, z=0), Vector3(x=0, y=0, z=0)))
        #self.rate.sleep
        self.t_paused = rospy.get_time()
        return EmptyResponse()

    def resume(self, event=None):
        self.flag = True
        self.t_diff += rospy.get_time() - self.t_paused
        #self.pathing()
        return EmptyResponse()

    def pathing(self, event=None):    
        t = rospy.get_time() - self.__t - self.t_diff
        #print(t)
        x, y, v, w = self.figure_eight.get_velocity(t)
        #print(f"x =  {v}") 
        movement = Twist(Vector3(x=v, y=0, z=0), Vector3(x=0, y=0, z=w))
        #print(f"v and w = {movement}")
        self.pub.publish(movement)
        #self.rate.sleep()
    
    def move(self):
        while not rospy.is_shutdown():
            if self.flag == True:
                self.pathing()
            else:
                self.pub.publish(Twist(Vector3(x=0,y=0,z=0), Vector3(x=0,y=0,z=0)))
            self.rate.sleep()

if __name__=='__main__':
    rospy.init_node("trajectory", log_level=rospy.DEBUG)
    node = Trajectory()
    #rate = rospy.Rate(70) #__pub_freq
    node.move()
    rospy.spin()
    
    #rospy.Timer(rospy.Duration(1.0/70.0), node.pathing)
    #rospy.spin()
