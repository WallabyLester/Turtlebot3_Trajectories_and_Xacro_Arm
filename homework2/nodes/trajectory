#!/usr/bin/env python

'''
Publishes a cmd_vel (geometry_msgs/Twist) message at a fixed frequency, causing the turtlebot to follow the desired open-loop trajectory
It is up to you to find an appropriate frequency, but 10 Hz is too slow and 1 kHz is faster than needed.

Broadcasts:
A static transform from world to odom.
The world frame and odom frame are co-located. When the turtlebot is at (0, 0, 0) in the odom frame it is at 0,0,θ0 in the world frame, where θ0 is the initial angle of the robot on its figure-eight trajectory
Thus, when the turtlebot starts, it can initiate its odometry to (0,0,0) but always be facing the correct direction in the odometry frame

Services:
pause (type up to you) Stop the turtle's motion, in a way that the trajectory can be resumed
resume (type up to you) Resume the turtle's motion along the trajectory

Parameters:
width: The width of the figure eight
height: The height of the figure eight
period: The amount of time it takes to complete the figure eight
~pub_freq: The frequency at which to publish the messages. This is a private parameter.
Pick parameters that fit your location and the turtlebot's capabilities.

Idea: Two classes (import homework2 python package)
FigureEight is responsible for all calculations related to FigureEight trajectories:
It should be able to provide the trajectory coordinates and derivatives at any given time for a set of parameters.

Kinematics is responsible for the calculations related to the kinematics of the turltebot
This class can use FigureEight to compute the appropriate control inputs to follow the trajectory

In general, multiple trajectory shapes could be supported by substituting FigureEight with another class for a different trajectory
You need not support multiple trajectory shapes, but this may be a helpful way of thinking about how to organize the code.
'''

import rospy
from std_srvs.srv import Empty, EmptyResponse
from geometry_msgs.msg import Twist, Vector3
import math
from homework2.comp_traj import FigureEight

#values = rospy.get_param("/figure_eight")
W = 5
H = 5
T = 5
#__pub_freq = rospy.get_param("~pub_freq")


class Trajectory:
    """ Calculates based on Figure Eight trajectories and provides coordinates 
    """
    def __init__(self):
        # temporary service type
        self.__pause = rospy.Service("pause", Empty, self.stop)
        self.__resume = rospy.Service("resume", Empty, self.move)
        self.pub = rospy.Publisher("turtle1/cmd_vel", Twist, queue_size=10)
        #self.__pub_freq = rospy.get_param("~pub_freq")
        self.__pub_freq = 400
        self.figure_eight = FigureEight(W, H, T)
        self.flag = 0  # use for time
        self.__t = rospy.get_time()
        

    def stop(self, event=None):
        if self.flag == 1:
            #rospy.wait_for_service("pause")
            stop = rospy.Publisher("turtle1/cmd_vel", Twist, queue_size=10)
            stop.publish(Twist(Vector3(x=0, y=0, z=0), Vector3(x=0, y=0, z=0)))
            #self.__pause.spin()

    def move(self, event=None):
        #rospy.wait_for_service("resume")
        self.flag = 1

    def pathing(self, event=None):
        if self.flag == 1:
            print(self.__t)
            x, y, v, w = self.figure_eight.get_velocity(self.__t)
            movement = Twist(Vector3(x=v, y=0, z=0), Vector3(x=0, y=0, z=w))
            print(movement)
            self.pub.publish(movement)


if __name__=='__main__':
    rospy.init_node("trajectory", log_level=rospy.DEBUG)
    node = Trajectory()
    rate = rospy.Rate(70) #__pub_freq

    #rospy.Timer(rospy.Duration(1.0/70.0), node.pathing)
    #rospy.spin()
    
    while not rospy.is_shutdown():
        node.pathing()
        rate.sleep()